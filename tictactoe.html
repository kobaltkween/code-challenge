
<!DOCTYPE html>
<!--
   Here is my response to your coding challenge.  
   Thanks so much for the opportunity.  
   I decided to make this in just HTML/CSS/JS, because it seemed like 
   a purely client side problem.  
   
   I see you support IE going pretty far back on Rare.us.  Which makes 
   sense for such a high traffic site.  I figure that fits your traffic 
   data. But since 
			* IE is now only supported in the latest version for the platform
			* Windows 7 and higher are the bulk of Windows OS's
			* Firefox and Chrome both push updates pretty regularly and heavily
			* Apple seems to do the same with Safari
			
	I'm going to stick with IE10+ and modern browser solutions for this 
	limited audience.
-->
<html>
	<head>
		<meta charset="utf-8">
		<title>Tic Tac Toe Coding Challenge</title>
		<link href="https://fonts.googleapis.com/css?family=Lora:400,400italic" rel="stylesheet" type="text/css">
		<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400italic,600,600italic' rel="stylesheet" type="text/css">
		<style>
			* {
					box-sizing: border-box;
				}
			html {
				background-color: #f4f4f4;
			}
			body {
				background-color: white;
				color: black;
				margin: 0 auto;
				max-width: 840px;
				min-width: 420px;
				width: 75%;
				border-left: 1px solid #ddd;
				border-right: 1px solid #ddd;
				box-shadow:0 0 25px #ddd;
				min-height: 100vh;
				padding: 10px;
			}
			body, p, ul, ol, td {
				font-family: "Source Sans Pro", Helvetica, Arial, sans-serif;
				margin-top: 0;
				padding-top: 0;
			}
			h1, h2, h3 {
				font-family: Lora, Georgia, Times, serif;
				font-weight:  normal;
				margin-top: 0;
			}
			h1 {
				font-size: 48px;
				text-align: center;
				margin-bottom: 25px;
				padding-top: 15px;
			}
			table {
				border-collapse: collapse;
			}
			#board, #instructions {
				position: relative;
				float: left;
				margin: 1%;
				padding: 1%;
				width: 48%;
				min-width: 380px;
			}
			#board table {
				height: 300px;
				width: 300px;
				margin: 20px;
			}
			#board table td {
				-webkit-transition: color 0.25s, background-color 0.25s;
				transition: color 0.25s, background-color 0.25s;
				height: 100px;
				width: 100px;
				text-align: center;
				vertical-align: center;
				font-size: 48px;
				font-family: Lora, Georgia, Times, serif;
			}
			#board table tr#row2 {
				border-top: 1px solid #444;
				border-bottom: 1px solid #444;
			}
			#board table tr td:nth-child(2){
				border-right: 1px solid #444;
				border-left: 1px solid #444;
			}
			#board .num {
				color: #ccc;
				font-size: 12px;
				font-family: Lora, Georgia, Times, serif;
			}
			.mark {
				font-size: 30px;
				padding: 10px;
				font-family: Lora, Georgia, Times, serif;
				font-weight: 600;
				vertical-align: middle;
				cursor: pointer;
				display: inline-block;
			}
			.mark:focus, #board table tr td:focus {
				background-color: #eee;
			}
			.warning {
				font-size: 20px;
				font-weight: 600;
			}
			.right {
				text-align: right;
			}
			a#reset {
				-webkit-transition: all 0.5s ease;
				transition: all 0.5s ease;
				border: 1px solid #ddd;
				background-color: #eee;
				box-shadow: 
					inset 0 0 8px #fff,
					inset 0 0 1px #fff,
					0 0 2px #ddd;
				padding: 10px 20px;
				border-radius: 50vh;
				font-size: 20px;
				display: none;
			}
			a#reset:hover, a#reset:focus {
				box-shadow: 
					inset 0 0 15px #fff,
					inset 0 0 4px #fff,
					0 0 16px #eee,
					0 2px 4px #888;
				cursor: pointer;
				outline: 0;
				text-decoration: underline dotted black;
			}
			a#reset:active {
				box-shadow: 
					inset 0 0 20px #fff,
					inset 0 0 4px #fff,
					0 0 1px #ddd;
				text-decoration-color: white;
			}
			p#chosen {
				display: none;
			}
			#board p.message {
				font-size: 20px;
				color: white;
				padding: 10px;
				border-radius: 10px;
				margin-top: 30px;
			}
			footer {
				clear: both;
				text-align: center;
				margin-top: 30px;
				padding: 10px;
				font-size: 0.85em;
				font-style: italic;
			}
		</style>
	</head>

	<body>
		<header>
			<h1>TicTacToe Coding Challenge</h1>
		</header>
		<main>
			<noscript>
				<p class="warning">Sorry! This game won't work unless you enable JavaScript.  
				Please change your browser or plugin settings to allow this script to run.</p>
			</noscript>
			<div id="board">
				<p id="choice">Choose: <span class="mark">X</span> or <span class="mark">O</span></p>
				<p id="chosen">You chose: <span class="mark">X</span> You get to make the first move.</p>
				<table>
					<tr id="row1"><td></td><td></td><td></td></tr>
					<tr id="row2"><td></td><td></td><td></td></tr>
					<tr id="row3"><td></td><td></td><td></td></tr>
				</table>
				<p class="right"><a id="reset">Play Again</a></p>
			</div>
			<div id="instructions">
				<h2>Instructions</h2>
				<ol>
					<li>Click or tab and select "X" or "O".</li>
					<li>Click or tab and select (press [ENTER]) on the empty square you want to use.  You can also use numbers 1 - 9 to navigate to the square you want.</li>
					<li>Play until you win or the computer does.</li>
					<li>If you want to play again, press Play Again, or press [ENTER].</li>
				</ol>
			</div>
		</main>
		<footer><p>Made with jQuery.</p></footer>
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.3/jquery.min.js"></script>
		<script type="text/javascript">	
			(function($) {
				var pWinMess = "You won!";
				var cWinMess = "Sorry, you lost.";
				// Initialize player mark choice
				var pMark = cMark = "";
				// Keeping the wins constant now
				var wins = [[1,2,3], [4,5,6], [7,8,9], [1,4,7], [2,5,8], 
							[3,6,9], [1,5,9], [3,5,7]];
				var board = Array(9);

				var $blocks = $("#board table td");
				
				// Columns are useful for  arrow navigation
				var cols = {col1: [1, 4, 7], col2: [2, 5, 8], col3: [3, 6, 9]};
				// Markcount accessed by multiple functions
				var markCount;
				// Creating a depth variable for minimax move function
				var maxDepth = 8;
				// Creating loop variable so can make console calls for a limited number of loops
				var loop = 0;
				var choice;
				// Add numbers to the squares 
				numStartX = parseInt ($("#board table").position().left) + parseInt($("#board table").css("marginTop")) + 5;
				numStartY = parseInt ($("#board table").position().top) + parseInt($("#board table").css("marginTop")) + 5;
				
				bHeight = bWidth = parseInt($blocks.height());
				for (var i = 1; i <= 3; i++) {
					for (var j = 0; j < 3; j++) {
						num = i + j * 3;
						x = numStartX + (i -1) * bWidth;
						y = numStartY + j * bHeight;
						number = $("<div />", {"class" : "num"})
									.text(num)
									.css({
										position: "absolute", 
										left: x,
										top: y});
										
						$("#board").append(number);
					}
				}
				
				// Make choice buttons navigable and functional
				$("#choice span.mark")
					.attr({
						role: "button",
						tabindex: function(i){ return i + 1}})
					.on("click keypress", function(e) { chooseMark(e, $(e.target).text()); });
				
				// Set up reset button
				// Give the reset button the ability to reset the game
				$("a#reset").on("click keypress", function(e) {
					if (e.type === "click" || (e.type === "keypress" 
								&& e.which === 13)) {
						initBoard();
					}	
				});
				
				// Initialize interface after a game
				function initBoard() {
					//console.log("Initialize the board.");
					// Re-initializes values
					pMark = cMark = "";
					board = Array(9);
					score = 0;
					numNodes = 0;
					maxDepth  = 6;
					// Get rid of any messages or warnings
					$("#board .warning, #board .message").remove();
					// Hide reset and chosen
					$("#chosen, a#reset").hide();
					// Bring back choice paragraph
					$('#choice').show();
					// Make choices active again
					$("#choice span.mark")
						.attr({
							role: "button",
							tabindex: function(i){ return i + 1}})
						.on("click keypress");
					// Remove board styles
					$("#board table, #board tr, #board td").removeAttr("style");
					// Empty out board cells
					$blocks.text("");
				}
				
				// Give player ability to choose "X" or "O"
				function chooseMark(e, pMark) {
					if (e.type === "click" || (e.type === "keypress" && e.which === 13)) {
						cMark = (pMark === "X") ? "O" : "X";
						$("#chosen span.mark").html(pMark);
						$("#choice").fadeOut(250, function() {
							$("#chosen").fadeIn(250, function() {
								// Made this into a function for better readability
								turnOnBlocks(pMark);
							});
						});
					}
				}
				
				// Make board's squares clickable
				function turnOnBlocks(pMark){
					$blocks
						.attr({
							role: "button",
							tabindex: function(i){ return i + 1},
							id: function(i){ return i + 1 }
						})
						.on("click keypress", function(e) {
							if ((e.type === "click" || (e.type === "keypress" && e.which === 13)) && $(this).text() === "") {
								place = $(this).prop("tabindex");
								// Add player's mark to the visible board
								$(this).text(pMark);
								// Change the board array
								if (board[place - 1] === undefined) {
									board[place - 1] = pMark;
								} else {
									// Something has gone very wrong
									console.log("Board isn't blocking squares already chosen.");
								}
								// Test for win or finished, change possible wins
								pScore = getScore(pMark, board, true, false);
								if (pScore[0]) {
									// Calculate best move
									minimax(cMark, board, false, 0, -Infinity, Infinity);
									//nextBoard = recurseMinimax(cMark, board, false, 0)[1];
									console.log("Next board: " + nextBoard);
									console.log("Existing board: " + board);
									cPlace = choice + 1;
									console.log("Move suggested is " + cPlace);
									
									// Add computer's mark to the visible board
									$blocks.eq(cPlace - 1).text(cMark).off("click");
									// Change the board array
									if (board[cPlace - 1] === undefined) {
										board[cPlace - 1] = cMark;
									}
									// See if the computer made a winning move or if game is over
									var cScore = getScore(cMark, board, false);
									if (!cScore[0]) {
										if (cScore[1] === 0) {
											noWin();
										} else if (cScore[1] === 1) {
											win(markCount, false);
										}
									} 	
									
								} else {
									if (pScore[1] === 0) {
										noWin();
									} else if (pScore[1] === -1) {
										win(markCount, true);
									}
								}
								// Remove click event
								$(this).off("click");
							} else if (e.type === "keypress") {
								// NOTE: e.which registered 0 for all arrow keys
								// Need to use e.keyCode for all of them
								// If press left arrow
								// See if it's not in the left most column
								if (e.keyCode === 37 && cols.col1.indexOf($(this).prop("tabindex")) === -1) {
										// If not, change focus to cell - 1	 
										$blocks.eq($(this).prop("tabindex") - 2).focus();
								} else if (e.keyCode === 38 && $(this).parent().attr("id") !== "row1") {
									// If press up arrow
									// See if it's not in the top row
									// If not, change focus to cell - 3
									$blocks.eq($(this).prop("tabindex") - 4).focus();
								} else if (e.keyCode === 39 && cols.col3.indexOf($(this).prop("tabindex")) === -1) {
									// If press right arrow
									// See if we're in the right-most column
									// If not, change focus to cell + 1
									$blocks.eq($(this).prop("tabindex")).focus();
								} else if (e.keyCode === 40 && $(this).parent().attr("id") !== "row3") {
									// If press down arrow
									// See if we're in the bottom column
									// If not, change focus to cell + 3
									$blocks.eq($(this).prop("tabindex") + 2).focus();
								} else if (!isNaN(String.fromCharCode(e.which))) {
									// The numbers are all keyCode 0
									// Need to use which for them
									var num = String.fromCharCode(e.which);
									if (num == 0) {
										num = 1;
									}
									// Move the focus to cell number 
									$blocks.eq(num -1).focus();
								}
							}
						});		
				}
				
				
				// Make a game over interface
				function endGame(mess, col) {
					var message = $("<p />", {"class" : "message"})
								.css("background-color", col).text(mess);
					$("#board table").after(message);
					$("#board .message").show();
					// Make the board inactive
					$blocks
						.off("click keypress")
						.removeAttr("tabindex")
						.css({"background-color" : "#ddd", color: "#aaa"});
					$("#board table tr#row2, #board table tr td:nth-child(2)").css("border-color", "#aaa");
					// Make the reset button visible and give it focus
					$("a#reset")
						.fadeIn(250)
						.attr({
							role: "button",
							tabindex: 1
						}).focus();
				}
				
				// Find spaces in the board array
				function findSpaces(board) {
					var spaces = [];
					for (i = 0; i < board.length; i++) {
						if (board[i] === undefined) {
							spaces.push(i + 1);
						}
					}
					return spaces;
				}
				
				// Set the interface to show a win when game ends
				function win(marked, player) {
					// console.log("Win function called!");
					// Set up response
					var mess = (player) ? pWinMess : cWinMess;
					// Mark the winning squares
					var col = (player) ? "green" : "blue";
					endGame(mess, col);
					// Mark the winning squares on the board
					for (i = 0; i < marked.length; i++) {
						$blocks.eq(marked[i] - 1)
							.css({
								color: "white",
								"background-color": col
							});
					}
				}
				
				// Set the interface to show a draw when game ends
				function noWin() {
					// console.log("No one won.");
					var mess = "This game was draw.  Good game!";
					endGame(mess, "grey");
				}
				
				function newMove(board1, board2) {
					for (var i = 0; i < board1.length; i++) {
						if (board1[i] !== board2[i]) {
							return i + 1;
						} 
					}
					return 0;
				}
				
				// Function returns false if new mark won game or finished it
				// True if it hasn't
				// Adding minmax scoring, and checking spaces here
				// Setting function to return an array such that
				// array[0] = game still in play or not
				// array[1] = score - computer win = 1, tie or none = 0, player win = -1
				// Had significant problems with the scoring function that needed structured testing
				function getScoreMine(mark, board, player) {
					var oMark = (mark === "X") ? "O" : "X";
					for (i = 0; i < wins.length; i++) {
						// Initialize array of squares with marks for win indication
						markCount = [];
						for (j = 0; j < wins[i].length; j++) {
							square = board[wins[i][j] -1];
							if (square !== undefined) {
								// Break the loop if there are opposing marks in the win
								if (j > 0 && markCount.length > 0) {
									prevSquare = board[wins[i][j - 1] - 1];
									if (square !==  prevSquare) {
										break;
									}
								}
								// console.log(i + ", "  + j);
								// console.log("Mark: " + board[wins[i][j] - 1]);
								// If the loop hasn't broken because win is impossible
								// Add the win to the markCount in case the visible board needs a win marked
								markCount.push(wins[i][j]);
								if ((board[wins[i][j] - 1] === mark && !player)
											|| (board[wins[i][j] -1] === oMark && player)) { 
									win = 1;
								} else{
									win = -1;
								}
								// console.log("Win: " + win);
							}
						}
						//console.log("Mark count is: " + markCount.length);
						// If someone has won
						if (markCount.length === 3) {
							return [false, win];
						}
						//console.log("Looked for win in: " + wins[i]);
					}
					
					// Check to see if there are any moves left to make
					if (findSpaces(board).length > 0) {
						return [true, 0];
					} else {
						// Game finished in a tie - score 0
						return [false, 0];
					}
				}
				/*
				// Testing the scoring function, and fixing it when it fails
				var testBoard1 = ["X", "X", "X", "O", "X", "O", "X", "O", "X"]; // Full X win
				var testBoard2 = ["O", "X", "O", "X", "O", "X", "O", "X", "O"];  // Full O win
				var testBoard3 = ["O", "X", "O", "O", "X", "X", "X", "O", "O"];  // Full tie
				var testBoard4 = ["X", "X", "X", "O", "X", "O", undefined, undefined, undefined]; // Unfinished X win
				var testBoard5 = ["X", "O", undefined, undefined, "X", undefined, undefined, undefined, undefined]; // Unfinished with no win
				testScore = getScoreMine("X", testBoard1, true);
				console.log("T1a: Playing: " + testScore[0] + ", Score: " + testScore[1]);
				console.log("A1a: Playing: false, Score: -1");
				testScore = getScoreMine("X", testBoard1, false);
				console.log("T1b: Playing: " + testScore[0] + ", Score: " + testScore[1]);
				console.log("A1b: Playing: false, Score: 1");
				testScore = getScoreMine("O", testBoard2, true);
				console.log("T2a: Playing: " + testScore[0] + ", Score: " + testScore[1]);
				console.log("A2a: Playing: false, Score: -1");
				testScore = getScoreMine("O", testBoard2, false);
				console.log("T2b: Playing: " + testScore[0] + ", Score: " + testScore[1]);
				console.log("A2b: Playing: false, Score: 1");
				testScore = getScoreMine("X", testBoard2, true);
				console.log("T2c: Playing: " + testScore[0] + ", Score: " + testScore[1]);
				console.log("A2c: Playing: false, Score: 1");
				testScore = getScoreMine("X", testBoard3, false);
				console.log("T3a: Playing: " + testScore[0] + ", Score: " + testScore[1]);
				console.log("A3a: Playing: false, Score: 0");
				testScore = getScoreMine("X", testBoard3, true);
				console.log("T3b: Playing: " + testScore[0] + ", Score: " + testScore[1]);
				console.log("A3b: Playing: false, Score: 0");
				testScore = getScoreMine("O", testBoard3, true);
				console.log("T3c: Playing: " + testScore[0] + ", Score: " + testScore[1]);
				console.log("A3c: Playing: false, Score: 0");
				testScore = getScoreMine("X", testBoard4, true);
				console.log("T4a: Playing: " + testScore[0] + ", Score: " + testScore[1]);
				console.log("A4a: Playing: false, Score: -1");
				testScore = getScoreMine("X", testBoard4, false);
				console.log("T4b: Playing: " + testScore[0] + ", Score: " + testScore[1]);
				console.log("A4b: Playing: false, Score: 1");
				testScore = getScoreMine("O", testBoard4, false);
				console.log("T4c: Playing: " + testScore[0] + ", Score: " + testScore[1]);
				console.log("A4c: Playing: false, Score: -1");
				testScore = getScoreMine("X", testBoard5, true);
				console.log("T5a: Playing: " + testScore[0] + ", Score: " + testScore[1]);
				console.log("A5a: Playing: true, Score: 0");
				testScore = getScoreMine("X", testBoard5, false);
				console.log("T5b: Playing: " + testScore[0] + ", Score: " + testScore[1]);
				console.log("A5b: Playing: true, Score: 0");
				testScore = getScoreMine("O", testBoard5, true);
				console.log("T5c: Playing: " + testScore[0] + ", Score: " + testScore[1]);
				console.log("A5c: Playing: true, Score: 0");*/
				
				// Making major changes to this function
				// Found that it couldn't block a triple move
				// More research found the minmax algorithm, so I'm applying that instead
				// Player is a true/false value indicating whether the move for the player or computer
				function minimax(mark, board, player, depth, alpha, beta) {
					var score = getScore(mark, board, player);
					if (!score[0]) {
						switch (score[1]) {
							case 1:
								return  10 - depth;
							case 0:
								return 0;
							case -1:
								return depth - 10;
						}
					}
						
					depth++;
					
					var availableMoves = findSpaces(board);
					var move, result, possible_game;
					var oMark = (mark === "X") ? "O" : "X";
					if (!player) {
						for (var i = 0; i < availableMoves.length; i++) {
							move = availableMoves[i];
							board[i] = mark;
							result = minimax(oMark, board, !player, depth, alpha, beta);
							possible_game = board.slice(0);
							board[i] = undefined;
							if (result > alpha) {
								alpha = result;
								if (depth == 1)
									choice = move;
							} else if (alpha >= beta) {
								return alpha;
							}
						}
						return alpha;
					} else {
						for (var i = 0; i < availableMoves.length; i++) {
							move = availableMoves[i];
							board[i] = mark;
							result = minimax(oMark, board, !player, depth, alpha, beta);
							possible_game = board.slice(0);
							board[i] = undefined;
							if (result < beta) {
								beta = result;
								if (depth == 1)
									choice = move;
							} else if (beta <= alpha) {
								return beta;
							}
						}
						return beta;
					}
				}
				
			}
			(jQuery));
		</script>
	</body>

</html>
